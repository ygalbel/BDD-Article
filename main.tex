\documentclass{article}      % Specifies the document class

\usepackage{amsmath}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{forloop}
\usepackage{graphicx}

\usepackage{subcaption}


\newcounter{ct}
\newcommand{\markdent}[1]{\forloop{ct}{0}{\value{ct} < #1}{\hspace{\algorithmicindent}}}
\newcommand{\markcomment}[1]{\Statex\markdent{#1}}

\algnewcommand\algorithmicforeach{\textbf{for each}}
\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}

\begin{document}
 \large Intro about re project \\
 \large BDD Modeling Process \\


     \includegraphics[width=3cm, height=3cm]{ex1.png}
We can see node A have two positives activators (B, C) and two repressors (D,E). The number inside A mark that A next value is set by two possible functions, function 1 and function 2. In this case function number 1 is “OrNegativeIsTrue” that mean one of all the repressors is activated and Function number 2 is “AndPositiveIsTrue” that mean all activators are needed to be on. 
Because Node A is controlled by one of this two functions, so we need to put an OR operator between them.
The observation for this example is:
\begin{table}[h]
\begin{tabular}{|l|l|l|l|l|l|}
\hline
\textbf{Time} & \textbf{A} & \textbf{B} & \textbf{C} & \textbf{D} & \textbf{E} \\ \hline
0             &            & 0          & 1          & 1          & 1          \\ \hline
1             & 1          &            &            &            &            \\ \hline
\end{tabular}
\end{table}
Now we have to decide if one of the function of node A can satisfy the observation we take. To perform this, we digital every function with following notation:
#F2\_A , mean function number 2 is selected function to node A.
We have to ensure that one (but more than one is right too) of the function will be selected, so we add an “or” function between the two functions.
To do that we have to calculate the function of A for every t.
\[  a_1 = 1 \wedge b_0 = 0 \wedge c_0 = 1 \wedge d_0 = 1 \wedge e_0 = 1 \wedge

\\
(#F_1_a \vee #F_2_A) \wedge
\\
((#F_1_a \wedge (e_0 \vee d_0))) \vee 
\\
(#F_2_a \wedge (b_0 \wedge c_0))
 \]

The BDD that will be created for this expression is:
\includegraphics[width=6cm, height=8cm]{bdd1.png}
\begin{algorithm} \caption{Process Experiments List}
\begin{algorithmic}[1]
\Function {ProcessExperiments}{}
\State $list \gets \text{list of experiments}$
\State $booleanNetwork \gets \text{boolean network graph and functions}$
\State \textbf{begin function}
    \ForEach {$e_1$, $e_2$ pair of experiments in list}
        \State $res \gets FindValidMerges(e_1, e_2, bn)$
        \State $newList \gets \text{a copy of experiments list}$
        \State \text{add res to top of the list (can be multiple)}
        \State \text{call} $ProcessExperiments(newList, booleanNetwork)$
        \Comment{Backtracking process}
    \EndFor
\EndFunction
\State \Comment{Missing part: how the algorithm finish}
\end{algorithmic}
\end{algorithm}
\begin{algorithm}
\begin{algorithmic}[1]
\Function {FindValidMerges}{}
\State $exp1 \gets \text{first experiment}$
\State $exp2 \gets \text{second experiment}$
\State $booleanNetwork \gets \text{boolean network graph and functions}$
\State \textbf{begin function}
    \ForEach {s state in exp1}
        \State $mergedExperiment \gets \text{connect s with begin of exp2}$
        \If{\text{IsValidMerge(mergedExperiment, booleanNetwork)}}
                \State \text{add mergedExperiment to returnList }
        \EndIf
    \EndFor
    \ForEach {s state in exp2}
        \State $mergedExperiment \gets \text{connect s with begin of exp1}$
        \If{IsValidMerge(mergedExperiment, booleanNetwork)}
                \State \text{add mergedExperiment to returnList }
        \EndIf
    \EndFor
\EndFunction
\end{algorithmic}
\end{algorithm}
\begin{algorithm}
\begin{algorithmic}[1]
\Function {IsValidMerge}{}
\State $exp \gets \text{an experiment}$
\State $booleanNetwork \gets \text{boolean network graph and functions}$
\State $bdd \gets \text{an new empty BDD}$
\State \text{Add states values to BDD}
\State $BDD \gets \text{an empty BDD}$
\State \textbf{begin function}
    \ForEach {\text{s state in experiment}}
        \State $BDD \gets \text {BDD AND s}$
    \EndFor
\State $functionBDD \gets \text{an empty BDD}$
    \ForEach {\text{v vertex in booleanNetwork}}
        \State $incomeEdges \gets \text{income edges to vertex v}$
        \State $availableFunctions \gets \text{available functions for vertex v}$
        \State $functionBDD \gets \text{functionBDD AND CreateFunctionRepresentation(v, availableFunctions, incomeEdges, experiment.length)}$
    \EndFor
\State $BDD \gets \text{BDD AND functionBDD}$
\State $BDD \gets \text{BDD AND 1}$
\If{BDD is Empty}
    \State \text{return false}
\EndIf
    \State \text{return true}
\EndFunction
\end{algorithmic}
\end{algorithm}
\begin{algorithm}
\begin{algorithmic}[1]
\Function {CreateFunctionRepresentation}{}
\State $availableFunctions \gets \text{list of possible functions}$
\State $letter \gets \text{current letter}$
\State $edges \gets \text{list of edges letter}$
\State $length \gets \text{experiment length}$
\State \textbf{begin function}
\State $functionBDD \gets \text{an empty BDD}$
    \For{\texttt{i=0;i<length;i++}}
        \State $tempBDD \gets \text{an empty BDD}$
        \ForEach {\text{F function in availableFunctions}}
            \State $tempBDD \gets \text{tempBDD OR ($f_i$ and $F_i$implementation(edges))}$
            \State \Comment{Missing part: optional parameters}
        \EndFor
        \State $tempBDD \gets \text{tempBDD AND (f1, f2, .., fn}$
        \State \Comment{ensure one of the function has been choosen}
        \State $functionBDD \gets \text{functionBDD AND $letter_{i+1}$ equal tempBDD}$
    \EndFor
    \State \text{return functionBDD}
\EndFunction
\end{algorithmic}
\end{algorithm}

\end{document}